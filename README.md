# Go CodeGen, a simple code generation system

`go-codegen` is a simple template-based code generation system for go.  By
annotating structs with specially tagged fields, go-codegen will generate code
based upon templates provided alongside your packages.

## Prior Art

This project is based off of the original `go-codegen` project by nullstyle.
It's essentially a complete rewrite of the codebase, only drawing on some of the
key concepts such as embedding structs to trigger code generation, and as such
should be considered a separate project.  Out of respect for nullstyle's
original work, this repository remains a fork of his original.

## Installation

```bash
go install github.com/cyborgmaster/go-codegen
```

## Example usage

go-codegen works by scanning your file for structs with fields annotated with a
`codegen` tag, and then will run the corresponding template with the same name
as the field type in the same folder where the field type is defined.

Take for example, the following go file:

```go
package main

import "fmt"

//go:generate go-codegen $GOFILE

type cmd interface {
	Execute() (interface{}, error)
	MustExecute() interface{}
}

// cmdGen is a template. Any type can have a template bound to it by creating
// the appropriate file in the same directory where the type is defined.
//
// aside: Blank structs are good to use for targeting templates
// as they do not affect the compiled package.
type cmdGen struct {}

type HelloCommand struct {
	// HelloCommand needs to have the `cmdGen` template invoked upon it.
	// By tagging cmdGen, we tell go-codegen to do so.
	cmdGen `codegen:""`
	Name string
}

func (cmd *HelloCommand) Execute() (interface{}, error) {
	return "Hello, " + cmd.Name, nil
}

type GoodbyeCommand struct {
	cmdGen `codgen:""`
	Name string
}

func (cmd *GoodbyeCommand) Execute() (interface{}, error) {
	return "Goodbye, " + cmd.Name, nil
}

func main() {
	var c cmd
	c = &HelloCommand{Name: "You"}
	fmt.Println(c.MustExecute())
	c = &GoodbyeCommand{Name: "You"}
	fmt.Println(c.MustExecute())
}

```

Notice that `HelloCommand` doesn't have a `MustExecute` method.  This code will
be generated by `go-codegen`.  Now we need to write the `cmdGen` template.

Create a new file named `cmdGen.tmpl` in the same package where the cmdGen
struct is defined:

```go
// MustExecute behaves like Execute, but panics if an error occurs.
func (cmd *{{ .StructName }}) MustExecute() interface{} {
	result, err := cmd.Execute()
	if err != nil {
		panic(err)
	}
	return result
}
```

Notice the `{{ .StructName }}` expression:  It's just normal go template code.

Now, given both files, lets generate the code.  Run `go generate .` in the
package directory, and you'll see a file called `main_generated.go` whose
content looks like:

```go
package main

// MustExecute behaves like Execute, but panics if an error occurs.
func (cmd *HelloCommand) MustExecute() interface{} {
	result, err := cmd.Execute()

	if err != nil {
		panic(err)
	}

	return result
}

// MustExecute behaves like Execute, but panics if an error occurs.
func (cmd *GoodbyeCommand) MustExecute() interface{} {
	result, err := cmd.Execute()

	if err != nil {
		panic(err)
	}

	return result
}
```



## Template Invocation

Templates are invoked by annotating a field with a `codegen` struct tag.

### Template Data

The "data" available in a template invocation is represented with a
`TemplateContext` struct.  You can see it
[here](https://github.com/CyborgMaster/go-codegen/blob/master/template.go#L41).

### Arguments

String arguments may be passed to the template by including them in the struct
tag as `key=value` pairs, comma separated. e.g.

```go
type HelloArgs struct {
	// The argsGen template will have available to it a "hello" arg with the
	// value "there", and a "cool" arg with the value "stuff".
	argsGen `codegen:"hello=there,cool=stuff"`

	// other fields ...
}
```

This are available inside the template by calling `$.Arg`, and their presence
can be detected by calling `$.HasArg`

```go
{{ if $.HasArg "hello" }}
  var hello := {{ $.Arg "hello" }}
{{ end }}
```

### Nested Templates

Templates may be recursive.  If the type which defines a template is itself a
struct with field with a `codegen` tag, then both the outer and the nested
template will be invoked on the root calling struct.

``` go
type FooGen struct {
	BarGen `codegen:""`
}

type BarGen struct{}

// Baz will have both the `FooGen` and the `BarGen` template invoked on it.
type Baz struct {
	FooGen `codgen:""`
}
```

Variables passed to the outer template invocation will be forwarded to the inner
invocation as well.

### Finding templates

A template is expected to be found within the same directory where the type
referenced by the field is defined, using a name of the form `TypeName.tmpl`.

### Adding Imports

A template may add additional imports into the generated go file by calling the
`AddImport` method on the `TemplateContext` like so:

```
{{ $.AddImport "net/http" }}
```

### Advanced Template Features

The [Sprig](http://masterminds.github.io/sprig/) template library is available
as global functions within a template.  In addition, the `singular` and `plural`
methods from [jinzhu/inflection](https://github.com/jinzhu/inflection), are
available.

The entire type system of your program is parsed using the go compiler and is
inspectable from within the template.  The struct that is the target of the
invocation is available at `.Struct` and is a
[`types.Struct`](https://pkg.go.dev/go/types#Struct).  This can be used to check
nearly all properties of your struct and its fields.  A couple of helper
functions are available to make it easier:

- `typeName` converts a `types.Type` to a string in the format `"package.Name"`
- `structField` gets a field from a struct by name.
- `pointerType` wraps an existing `types.Type` in a new one representing a
  pointer to that type.
- `$.Implements` returns true if a `types.Type` implements an interface, given
  by fully qualified name.

This lets you do all sorts of things like find the field in your struct that
embeds a type from a specific package:

``` go
{{ range $fieldNum := until .Struct.NumFields }}
  {{ $f := $.Struct.Field $fieldNum }}
  {{ $type := $f.Type | typeName }}
  {{ if $f.Embedded | and ($type | hasPrefix "mypkg.") }}
     // codgen here ...
  {{ end }}
{{ end }}
```

or if a pointer to a given type implements an interface defined elsewhere:

``` go
{{ if $.Implements
  (pointerType $foundType)
  "github.com/user/project/package/DefinedInterface" }}

  // code here...

{{ end }}
```

or only assign a field if it exists:

``` go
func (s *{{ .StructName }}) Apply(value *some.Type) {
  {{ if structField .Struct "Name" }}
    s.Name = value.Name
  {{ end }}

  // more code...
}
```

## TODO

- Update examples in the `examples` directory (they are still from the old
  project) and add better ones.
